/* tslint:disable */
/* eslint-disable */
/**
 * DevBook.API, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccessTokenResponse
 */
export interface AccessTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof AccessTokenResponse
     */
    'tokenType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccessTokenResponse
     */
    'accessToken': string | null;
    /**
     * 
     * @type {number}
     * @memberof AccessTokenResponse
     */
    'expiresIn': number;
    /**
     * 
     * @type {string}
     * @memberof AccessTokenResponse
     */
    'refreshToken': string | null;
}
/**
 * 
 * @export
 * @interface AuthorDto
 */
export interface AuthorDto {
    /**
     * 
     * @type {string}
     * @memberof AuthorDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AuthorDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AuthorDto
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface BoardDataDto
 */
export interface BoardDataDto {
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof BoardDataDto
     */
    'gridNumbers': Array<Array<number>>;
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof BoardDataDto
     */
    'solutionNumbers': Array<Array<number>>;
}
/**
 * 
 * @export
 * @interface BookDto
 */
export interface BookDto {
    /**
     * 
     * @type {string}
     * @memberof BookDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BookDto
     */
    'name': string;
    /**
     * 
     * @type {ProductType}
     * @memberof BookDto
     */
    'productType': ProductType;
    /**
     * 
     * @type {number}
     * @memberof BookDto
     */
    'retailPrice': number;
    /**
     * 
     * @type {number}
     * @memberof BookDto
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof BookDto
     */
    'discountAmmount': number;
    /**
     * 
     * @type {string}
     * @memberof BookDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookDto
     */
    'coverImageUrl'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BookDto
     */
    'productCategoryIds'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof BookDto
     */
    'authorId': string;
}


/**
 * 
 * @export
 * @interface CreateAuthorCommand
 */
export interface CreateAuthorCommand {
    /**
     * 
     * @type {string}
     * @memberof CreateAuthorCommand
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAuthorCommand
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateBookCommand
 */
export interface CreateBookCommand {
    /**
     * 
     * @type {string}
     * @memberof CreateBookCommand
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBookCommand
     */
    'authorId': string;
    /**
     * 
     * @type {number}
     * @memberof CreateBookCommand
     */
    'retailPrice': number;
    /**
     * 
     * @type {number}
     * @memberof CreateBookCommand
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof CreateBookCommand
     */
    'discountAmmount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateBookCommand
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateBookCommand
     */
    'coverImageUrl'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBookCommand
     */
    'productCategoryIds'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreateProductCategoryCommand
 */
export interface CreateProductCategoryCommand {
    /**
     * 
     * @type {string}
     * @memberof CreateProductCategoryCommand
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateProjectInput
 */
export interface CreateProjectInput {
    /**
     * 
     * @type {string}
     * @memberof CreateProjectInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProjectInput
     */
    'details'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreateProjectInput
     */
    'hourlyRate'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreateProjectInput
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateProjectInput
     */
    'hexColor'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateWorkTaskInput
 */
export interface CreateWorkTaskInput {
    /**
     * 
     * @type {string}
     * @memberof CreateWorkTaskInput
     */
    'projectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkTaskInput
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkTaskInput
     */
    'details'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkTaskInput
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkTaskInput
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkTaskInput
     */
    'end': string;
}
/**
 * 
 * @export
 * @interface ForgotPasswordRequest
 */
export interface ForgotPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordRequest
     */
    'email': string | null;
}
/**
 * 
 * @export
 * @interface HttpValidationProblemDetails
 */
export interface HttpValidationProblemDetails {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof HttpValidationProblemDetails
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof HttpValidationProblemDetails
     */
    'title'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof HttpValidationProblemDetails
     */
    'status'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof HttpValidationProblemDetails
     */
    'detail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof HttpValidationProblemDetails
     */
    'instance'?: string | null;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof HttpValidationProblemDetails
     */
    'errors'?: { [key: string]: Array<string>; } | null;
}
/**
 * 
 * @export
 * @interface InfoRequest
 */
export interface InfoRequest {
    /**
     * 
     * @type {string}
     * @memberof InfoRequest
     */
    'newEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InfoRequest
     */
    'newPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InfoRequest
     */
    'oldPassword'?: string | null;
}
/**
 * 
 * @export
 * @interface InfoResponse
 */
export interface InfoResponse {
    /**
     * 
     * @type {string}
     * @memberof InfoResponse
     */
    'email': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof InfoResponse
     */
    'isEmailConfirmed': boolean;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string | null;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string | null;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'twoFactorCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'twoFactorRecoveryCode'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchAuthorCommandDto
 */
export interface PatchAuthorCommandDto {
    /**
     * 
     * @type {string}
     * @memberof PatchAuthorCommandDto
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchAuthorCommandDto
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchBookCommandDto
 */
export interface PatchBookCommandDto {
    /**
     * 
     * @type {string}
     * @memberof PatchBookCommandDto
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchBookCommandDto
     */
    'authorId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchBookCommandDto
     */
    'retailPrice'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchBookCommandDto
     */
    'price'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchBookCommandDto
     */
    'discountAmmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchBookCommandDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchBookCommandDto
     */
    'coverImageUrl'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchBookCommandDto
     */
    'productCategoryIds'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface PatchProjectCommandDto
 */
export interface PatchProjectCommandDto {
    /**
     * 
     * @type {string}
     * @memberof PatchProjectCommandDto
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchProjectCommandDto
     */
    'details'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchProjectCommandDto
     */
    'hourlyRate'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchProjectCommandDto
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchProjectCommandDto
     */
    'hexColor'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchWorkTaskCommandDto
 */
export interface PatchWorkTaskCommandDto {
    /**
     * 
     * @type {string}
     * @memberof PatchWorkTaskCommandDto
     */
    'projectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchWorkTaskCommandDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchWorkTaskCommandDto
     */
    'details'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchWorkTaskCommandDto
     */
    'date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchWorkTaskCommandDto
     */
    'start'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchWorkTaskCommandDto
     */
    'end'?: string | null;
}
/**
 * 
 * @export
 * @interface ProductCategoryDto
 */
export interface ProductCategoryDto {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ProductDto
 */
export interface ProductDto {
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'name': string;
    /**
     * 
     * @type {ProductType}
     * @memberof ProductDto
     */
    'productType': ProductType;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    'retailPrice': number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    'discountAmmount': number;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'coverImageUrl'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductDto
     */
    'productCategoryIds'?: Array<string> | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ProductType = {
    NUMBER_0: 0
} as const;

export type ProductType = typeof ProductType[keyof typeof ProductType];


/**
 * @type ProductsGetAll200ResponseInner
 * @export
 */
export type ProductsGetAll200ResponseInner = BookDto;

/**
 * 
 * @export
 * @interface ProjectDto
 */
export interface ProjectDto {
    /**
     * 
     * @type {string}
     * @memberof ProjectDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDto
     */
    'details'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProjectDto
     */
    'hourlyRate'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectDto
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectDto
     */
    'hexColor'?: string | null;
}
/**
 * 
 * @export
 * @interface RefreshRequest
 */
export interface RefreshRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshRequest
     */
    'refreshToken': string | null;
}
/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'email': string | null;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'password': string | null;
}
/**
 * 
 * @export
 * @interface ResendConfirmationEmailRequest
 */
export interface ResendConfirmationEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof ResendConfirmationEmailRequest
     */
    'email': string | null;
}
/**
 * 
 * @export
 * @interface ResetPasswordRequest
 */
export interface ResetPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'email': string | null;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'resetCode': string | null;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'newPassword': string | null;
}
/**
 * 
 * @export
 * @interface StartWorkTaskInput
 */
export interface StartWorkTaskInput {
    /**
     * 
     * @type {string}
     * @memberof StartWorkTaskInput
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StartWorkTaskInput
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof StartWorkTaskInput
     */
    'start': string;
}
/**
 * 
 * @export
 * @interface TwoFactorRequest
 */
export interface TwoFactorRequest {
    /**
     * 
     * @type {boolean}
     * @memberof TwoFactorRequest
     */
    'enable'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof TwoFactorRequest
     */
    'twoFactorCode'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TwoFactorRequest
     */
    'resetSharedKey'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TwoFactorRequest
     */
    'resetRecoveryCodes'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TwoFactorRequest
     */
    'forgetMachine'?: boolean;
}
/**
 * 
 * @export
 * @interface TwoFactorResponse
 */
export interface TwoFactorResponse {
    /**
     * 
     * @type {string}
     * @memberof TwoFactorResponse
     */
    'sharedKey': string | null;
    /**
     * 
     * @type {number}
     * @memberof TwoFactorResponse
     */
    'recoveryCodesLeft': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TwoFactorResponse
     */
    'recoveryCodes'?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof TwoFactorResponse
     */
    'isTwoFactorEnabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TwoFactorResponse
     */
    'isMachineRemembered': boolean;
}
/**
 * 
 * @export
 * @interface UpdateAuthorCommandDto
 */
export interface UpdateAuthorCommandDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateAuthorCommandDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAuthorCommandDto
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateBookCommandDto
 */
export interface UpdateBookCommandDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateBookCommandDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBookCommandDto
     */
    'authorId': string;
    /**
     * 
     * @type {number}
     * @memberof UpdateBookCommandDto
     */
    'retailPrice': number;
    /**
     * 
     * @type {number}
     * @memberof UpdateBookCommandDto
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof UpdateBookCommandDto
     */
    'discountAmmount': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateBookCommandDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateBookCommandDto
     */
    'coverImageUrl'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateBookCommandDto
     */
    'productCategoryIds'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface UpdateProductCategoryCommandDto
 */
export interface UpdateProductCategoryCommandDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateProductCategoryCommandDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateProjectCommandDto
 */
export interface UpdateProjectCommandDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectCommandDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectCommandDto
     */
    'details'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateProjectCommandDto
     */
    'hourlyRate'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectCommandDto
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectCommandDto
     */
    'hexColor'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateWorkTaskCommandDto
 */
export interface UpdateWorkTaskCommandDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkTaskCommandDto
     */
    'projectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkTaskCommandDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkTaskCommandDto
     */
    'details'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkTaskCommandDto
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkTaskCommandDto
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkTaskCommandDto
     */
    'end': string;
}
/**
 * 
 * @export
 * @interface WorkTaskDto
 */
export interface WorkTaskDto {
    /**
     * 
     * @type {string}
     * @memberof WorkTaskDto
     */
    'id': string;
    /**
     * 
     * @type {ProjectDto}
     * @memberof WorkTaskDto
     */
    'project'?: ProjectDto | null;
    /**
     * 
     * @type {string}
     * @memberof WorkTaskDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkTaskDto
     */
    'details'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkTaskDto
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof WorkTaskDto
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof WorkTaskDto
     */
    'end'?: string | null;
}
/**
 * 
 * @export
 * @interface WorkTaskListResponse
 */
export interface WorkTaskListResponse {
    /**
     * 
     * @type {WorkTaskDto}
     * @memberof WorkTaskListResponse
     */
    'activeWorkTask'?: WorkTaskDto | null;
    /**
     * 
     * @type {{ [key: string]: Array<WorkTaskDto>; }}
     * @memberof WorkTaskListResponse
     */
    'workTasksInDay'?: { [key: string]: Array<WorkTaskDto>; } | null;
}

/**
 * BookStoreModuleAuthorEndpointsApi - axios parameter creator
 * @export
 */
export const BookStoreModuleAuthorEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateAuthorCommand} createAuthorCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorsCreate: async (createAuthorCommand: CreateAuthorCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAuthorCommand' is not null or undefined
            assertParamExists('authorsCreate', 'createAuthorCommand', createAuthorCommand)
            const localVarPath = `/bookstore/authors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAuthorCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorsDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authorsDelete', 'id', id)
            const localVarPath = `/bookstore/authors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorsGetAll: async (pageSize?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bookstore/authors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (offset !== undefined) {
                localVarQueryParameter['Offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorsGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authorsGetById', 'id', id)
            const localVarPath = `/bookstore/authors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchAuthorCommandDto} patchAuthorCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorsPatch: async (id: string, patchAuthorCommandDto: PatchAuthorCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authorsPatch', 'id', id)
            // verify required parameter 'patchAuthorCommandDto' is not null or undefined
            assertParamExists('authorsPatch', 'patchAuthorCommandDto', patchAuthorCommandDto)
            const localVarPath = `/bookstore/authors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchAuthorCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAuthorCommandDto} updateAuthorCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorsUpdate: async (id: string, updateAuthorCommandDto: UpdateAuthorCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authorsUpdate', 'id', id)
            // verify required parameter 'updateAuthorCommandDto' is not null or undefined
            assertParamExists('authorsUpdate', 'updateAuthorCommandDto', updateAuthorCommandDto)
            const localVarPath = `/bookstore/authors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAuthorCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookStoreModuleAuthorEndpointsApi - functional programming interface
 * @export
 */
export const BookStoreModuleAuthorEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookStoreModuleAuthorEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateAuthorCommand} createAuthorCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorsCreate(createAuthorCommand: CreateAuthorCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorsCreate(createAuthorCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleAuthorEndpointsApi.authorsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorsDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorsDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleAuthorEndpointsApi.authorsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorsGetAll(pageSize?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthorDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorsGetAll(pageSize, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleAuthorEndpointsApi.authorsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorsGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorsGetById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleAuthorEndpointsApi.authorsGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchAuthorCommandDto} patchAuthorCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorsPatch(id: string, patchAuthorCommandDto: PatchAuthorCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorsPatch(id, patchAuthorCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleAuthorEndpointsApi.authorsPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAuthorCommandDto} updateAuthorCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorsUpdate(id: string, updateAuthorCommandDto: UpdateAuthorCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorsUpdate(id, updateAuthorCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleAuthorEndpointsApi.authorsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BookStoreModuleAuthorEndpointsApi - factory interface
 * @export
 */
export const BookStoreModuleAuthorEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookStoreModuleAuthorEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateAuthorCommand} createAuthorCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorsCreate(createAuthorCommand: CreateAuthorCommand, options?: any): AxiosPromise<void> {
            return localVarFp.authorsCreate(createAuthorCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorsDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.authorsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorsGetAll(pageSize?: number, offset?: number, options?: any): AxiosPromise<Array<AuthorDto>> {
            return localVarFp.authorsGetAll(pageSize, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorsGetById(id: string, options?: any): AxiosPromise<AuthorDto> {
            return localVarFp.authorsGetById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchAuthorCommandDto} patchAuthorCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorsPatch(id: string, patchAuthorCommandDto: PatchAuthorCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.authorsPatch(id, patchAuthorCommandDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAuthorCommandDto} updateAuthorCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorsUpdate(id: string, updateAuthorCommandDto: UpdateAuthorCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.authorsUpdate(id, updateAuthorCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookStoreModuleAuthorEndpointsApi - object-oriented interface
 * @export
 * @class BookStoreModuleAuthorEndpointsApi
 * @extends {BaseAPI}
 */
export class BookStoreModuleAuthorEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {CreateAuthorCommand} createAuthorCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleAuthorEndpointsApi
     */
    public authorsCreate(createAuthorCommand: CreateAuthorCommand, options?: RawAxiosRequestConfig) {
        return BookStoreModuleAuthorEndpointsApiFp(this.configuration).authorsCreate(createAuthorCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleAuthorEndpointsApi
     */
    public authorsDelete(id: string, options?: RawAxiosRequestConfig) {
        return BookStoreModuleAuthorEndpointsApiFp(this.configuration).authorsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleAuthorEndpointsApi
     */
    public authorsGetAll(pageSize?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return BookStoreModuleAuthorEndpointsApiFp(this.configuration).authorsGetAll(pageSize, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleAuthorEndpointsApi
     */
    public authorsGetById(id: string, options?: RawAxiosRequestConfig) {
        return BookStoreModuleAuthorEndpointsApiFp(this.configuration).authorsGetById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PatchAuthorCommandDto} patchAuthorCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleAuthorEndpointsApi
     */
    public authorsPatch(id: string, patchAuthorCommandDto: PatchAuthorCommandDto, options?: RawAxiosRequestConfig) {
        return BookStoreModuleAuthorEndpointsApiFp(this.configuration).authorsPatch(id, patchAuthorCommandDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateAuthorCommandDto} updateAuthorCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleAuthorEndpointsApi
     */
    public authorsUpdate(id: string, updateAuthorCommandDto: UpdateAuthorCommandDto, options?: RawAxiosRequestConfig) {
        return BookStoreModuleAuthorEndpointsApiFp(this.configuration).authorsUpdate(id, updateAuthorCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BookStoreModuleBookEndpointsApi - axios parameter creator
 * @export
 */
export const BookStoreModuleBookEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateBookCommand} createBookCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        booksCreate: async (createBookCommand: CreateBookCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBookCommand' is not null or undefined
            assertParamExists('booksCreate', 'createBookCommand', createBookCommand)
            const localVarPath = `/bookstore/books`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBookCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchBookCommandDto} patchBookCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        booksPatch: async (id: string, patchBookCommandDto: PatchBookCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('booksPatch', 'id', id)
            // verify required parameter 'patchBookCommandDto' is not null or undefined
            assertParamExists('booksPatch', 'patchBookCommandDto', patchBookCommandDto)
            const localVarPath = `/bookstore/books/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchBookCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateBookCommandDto} updateBookCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        booksUpdate: async (id: string, updateBookCommandDto: UpdateBookCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('booksUpdate', 'id', id)
            // verify required parameter 'updateBookCommandDto' is not null or undefined
            assertParamExists('booksUpdate', 'updateBookCommandDto', updateBookCommandDto)
            const localVarPath = `/bookstore/books/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBookCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookStoreModuleBookEndpointsApi - functional programming interface
 * @export
 */
export const BookStoreModuleBookEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookStoreModuleBookEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateBookCommand} createBookCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async booksCreate(createBookCommand: CreateBookCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.booksCreate(createBookCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleBookEndpointsApi.booksCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchBookCommandDto} patchBookCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async booksPatch(id: string, patchBookCommandDto: PatchBookCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.booksPatch(id, patchBookCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleBookEndpointsApi.booksPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateBookCommandDto} updateBookCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async booksUpdate(id: string, updateBookCommandDto: UpdateBookCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.booksUpdate(id, updateBookCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleBookEndpointsApi.booksUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BookStoreModuleBookEndpointsApi - factory interface
 * @export
 */
export const BookStoreModuleBookEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookStoreModuleBookEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateBookCommand} createBookCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        booksCreate(createBookCommand: CreateBookCommand, options?: any): AxiosPromise<void> {
            return localVarFp.booksCreate(createBookCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchBookCommandDto} patchBookCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        booksPatch(id: string, patchBookCommandDto: PatchBookCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.booksPatch(id, patchBookCommandDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateBookCommandDto} updateBookCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        booksUpdate(id: string, updateBookCommandDto: UpdateBookCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.booksUpdate(id, updateBookCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookStoreModuleBookEndpointsApi - object-oriented interface
 * @export
 * @class BookStoreModuleBookEndpointsApi
 * @extends {BaseAPI}
 */
export class BookStoreModuleBookEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {CreateBookCommand} createBookCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleBookEndpointsApi
     */
    public booksCreate(createBookCommand: CreateBookCommand, options?: RawAxiosRequestConfig) {
        return BookStoreModuleBookEndpointsApiFp(this.configuration).booksCreate(createBookCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PatchBookCommandDto} patchBookCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleBookEndpointsApi
     */
    public booksPatch(id: string, patchBookCommandDto: PatchBookCommandDto, options?: RawAxiosRequestConfig) {
        return BookStoreModuleBookEndpointsApiFp(this.configuration).booksPatch(id, patchBookCommandDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateBookCommandDto} updateBookCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleBookEndpointsApi
     */
    public booksUpdate(id: string, updateBookCommandDto: UpdateBookCommandDto, options?: RawAxiosRequestConfig) {
        return BookStoreModuleBookEndpointsApiFp(this.configuration).booksUpdate(id, updateBookCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BookStoreModuleProductCategoryEndpointsApi - axios parameter creator
 * @export
 */
export const BookStoreModuleProductCategoryEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateProductCategoryCommand} createProductCategoryCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesCreate: async (createProductCategoryCommand: CreateProductCategoryCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProductCategoryCommand' is not null or undefined
            assertParamExists('productCategoriesCreate', 'createProductCategoryCommand', createProductCategoryCommand)
            const localVarPath = `/bookstore/productCategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductCategoryCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productCategoriesDelete', 'id', id)
            const localVarPath = `/bookstore/productCategories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesGetAll: async (pageSize?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bookstore/productCategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (offset !== undefined) {
                localVarQueryParameter['Offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productCategoriesGetById', 'id', id)
            const localVarPath = `/bookstore/productCategories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProductCategoryCommandDto} updateProductCategoryCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesUpdate: async (id: string, updateProductCategoryCommandDto: UpdateProductCategoryCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productCategoriesUpdate', 'id', id)
            // verify required parameter 'updateProductCategoryCommandDto' is not null or undefined
            assertParamExists('productCategoriesUpdate', 'updateProductCategoryCommandDto', updateProductCategoryCommandDto)
            const localVarPath = `/bookstore/productCategories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductCategoryCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookStoreModuleProductCategoryEndpointsApi - functional programming interface
 * @export
 */
export const BookStoreModuleProductCategoryEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookStoreModuleProductCategoryEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateProductCategoryCommand} createProductCategoryCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoriesCreate(createProductCategoryCommand: CreateProductCategoryCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoriesCreate(createProductCategoryCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleProductCategoryEndpointsApi.productCategoriesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoriesDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoriesDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleProductCategoryEndpointsApi.productCategoriesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoriesGetAll(pageSize?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductCategoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoriesGetAll(pageSize, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleProductCategoryEndpointsApi.productCategoriesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoriesGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoriesGetById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleProductCategoryEndpointsApi.productCategoriesGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProductCategoryCommandDto} updateProductCategoryCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoriesUpdate(id: string, updateProductCategoryCommandDto: UpdateProductCategoryCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoriesUpdate(id, updateProductCategoryCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleProductCategoryEndpointsApi.productCategoriesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BookStoreModuleProductCategoryEndpointsApi - factory interface
 * @export
 */
export const BookStoreModuleProductCategoryEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookStoreModuleProductCategoryEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateProductCategoryCommand} createProductCategoryCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesCreate(createProductCategoryCommand: CreateProductCategoryCommand, options?: any): AxiosPromise<void> {
            return localVarFp.productCategoriesCreate(createProductCategoryCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.productCategoriesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesGetAll(pageSize?: number, offset?: number, options?: any): AxiosPromise<Array<ProductCategoryDto>> {
            return localVarFp.productCategoriesGetAll(pageSize, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesGetById(id: string, options?: any): AxiosPromise<ProductCategoryDto> {
            return localVarFp.productCategoriesGetById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProductCategoryCommandDto} updateProductCategoryCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesUpdate(id: string, updateProductCategoryCommandDto: UpdateProductCategoryCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.productCategoriesUpdate(id, updateProductCategoryCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookStoreModuleProductCategoryEndpointsApi - object-oriented interface
 * @export
 * @class BookStoreModuleProductCategoryEndpointsApi
 * @extends {BaseAPI}
 */
export class BookStoreModuleProductCategoryEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {CreateProductCategoryCommand} createProductCategoryCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleProductCategoryEndpointsApi
     */
    public productCategoriesCreate(createProductCategoryCommand: CreateProductCategoryCommand, options?: RawAxiosRequestConfig) {
        return BookStoreModuleProductCategoryEndpointsApiFp(this.configuration).productCategoriesCreate(createProductCategoryCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleProductCategoryEndpointsApi
     */
    public productCategoriesDelete(id: string, options?: RawAxiosRequestConfig) {
        return BookStoreModuleProductCategoryEndpointsApiFp(this.configuration).productCategoriesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleProductCategoryEndpointsApi
     */
    public productCategoriesGetAll(pageSize?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return BookStoreModuleProductCategoryEndpointsApiFp(this.configuration).productCategoriesGetAll(pageSize, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleProductCategoryEndpointsApi
     */
    public productCategoriesGetById(id: string, options?: RawAxiosRequestConfig) {
        return BookStoreModuleProductCategoryEndpointsApiFp(this.configuration).productCategoriesGetById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateProductCategoryCommandDto} updateProductCategoryCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleProductCategoryEndpointsApi
     */
    public productCategoriesUpdate(id: string, updateProductCategoryCommandDto: UpdateProductCategoryCommandDto, options?: RawAxiosRequestConfig) {
        return BookStoreModuleProductCategoryEndpointsApiFp(this.configuration).productCategoriesUpdate(id, updateProductCategoryCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BookStoreModuleProductEndpointsApi - axios parameter creator
 * @export
 */
export const BookStoreModuleProductEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsDelete', 'id', id)
            const localVarPath = `/bookstore/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [offset] 
         * @param {string} [productCategoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGetAll: async (pageSize?: number, offset?: number, productCategoryId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bookstore/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (offset !== undefined) {
                localVarQueryParameter['Offset'] = offset;
            }

            if (productCategoryId !== undefined) {
                localVarQueryParameter['ProductCategoryId'] = productCategoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsGetById', 'id', id)
            const localVarPath = `/bookstore/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookStoreModuleProductEndpointsApi - functional programming interface
 * @export
 */
export const BookStoreModuleProductEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookStoreModuleProductEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleProductEndpointsApi.productsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [offset] 
         * @param {string} [productCategoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGetAll(pageSize?: number, offset?: number, productCategoryId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductsGetAll200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGetAll(pageSize, offset, productCategoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleProductEndpointsApi.productsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsGetAll200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGetById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleProductEndpointsApi.productsGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BookStoreModuleProductEndpointsApi - factory interface
 * @export
 */
export const BookStoreModuleProductEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookStoreModuleProductEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.productsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [offset] 
         * @param {string} [productCategoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGetAll(pageSize?: number, offset?: number, productCategoryId?: string, options?: any): AxiosPromise<Array<ProductsGetAll200ResponseInner>> {
            return localVarFp.productsGetAll(pageSize, offset, productCategoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGetById(id: string, options?: any): AxiosPromise<ProductsGetAll200ResponseInner> {
            return localVarFp.productsGetById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookStoreModuleProductEndpointsApi - object-oriented interface
 * @export
 * @class BookStoreModuleProductEndpointsApi
 * @extends {BaseAPI}
 */
export class BookStoreModuleProductEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleProductEndpointsApi
     */
    public productsDelete(id: string, options?: RawAxiosRequestConfig) {
        return BookStoreModuleProductEndpointsApiFp(this.configuration).productsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] 
     * @param {number} [offset] 
     * @param {string} [productCategoryId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleProductEndpointsApi
     */
    public productsGetAll(pageSize?: number, offset?: number, productCategoryId?: string, options?: RawAxiosRequestConfig) {
        return BookStoreModuleProductEndpointsApiFp(this.configuration).productsGetAll(pageSize, offset, productCategoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleProductEndpointsApi
     */
    public productsGetById(id: string, options?: RawAxiosRequestConfig) {
        return BookStoreModuleProductEndpointsApiFp(this.configuration).productsGetById(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IdentityApi - axios parameter creator
 * @export
 */
export const IdentityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [code] 
         * @param {string} [changedEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityConfirmEmailGET: async (userId?: string, code?: string, changedEmail?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity/confirmEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (changedEmail !== undefined) {
                localVarQueryParameter['changedEmail'] = changedEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityForgotPasswordPOST: async (forgotPasswordRequest?: ForgotPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity/forgotPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [useCookies] 
         * @param {boolean} [useSessionCookies] 
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityLoginPOST: async (useCookies?: boolean, useSessionCookies?: boolean, loginRequest?: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (useCookies !== undefined) {
                localVarQueryParameter['useCookies'] = useCookies;
            }

            if (useSessionCookies !== undefined) {
                localVarQueryParameter['useSessionCookies'] = useSessionCookies;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TwoFactorRequest} [twoFactorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityManage2faPOST: async (twoFactorRequest?: TwoFactorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity/manage/2fa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityManageInfoGET: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity/manage/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InfoRequest} [infoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityManageInfoPOST: async (infoRequest?: InfoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity/manage/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(infoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RefreshRequest} [refreshRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityRefreshPOST: async (refreshRequest?: RefreshRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterRequest} [registerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityRegisterPOST: async (registerRequest?: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResendConfirmationEmailRequest} [resendConfirmationEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityResendConfirmationEmailPOST: async (resendConfirmationEmailRequest?: ResendConfirmationEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity/resendConfirmationEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendConfirmationEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResetPasswordRequest} [resetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityResetPasswordPOST: async (resetPasswordRequest?: ResetPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity/resetPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityApi - functional programming interface
 * @export
 */
export const IdentityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [code] 
         * @param {string} [changedEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityConfirmEmailGET(userId?: string, code?: string, changedEmail?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityConfirmEmailGET(userId, code, changedEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.identityConfirmEmailGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityForgotPasswordPOST(forgotPasswordRequest?: ForgotPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityForgotPasswordPOST(forgotPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.identityForgotPasswordPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} [useCookies] 
         * @param {boolean} [useSessionCookies] 
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityLoginPOST(useCookies?: boolean, useSessionCookies?: boolean, loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityLoginPOST(useCookies, useSessionCookies, loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.identityLoginPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TwoFactorRequest} [twoFactorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityManage2faPOST(twoFactorRequest?: TwoFactorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFactorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityManage2faPOST(twoFactorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.identityManage2faPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityManageInfoGET(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityManageInfoGET(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.identityManageInfoGET']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {InfoRequest} [infoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityManageInfoPOST(infoRequest?: InfoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityManageInfoPOST(infoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.identityManageInfoPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RefreshRequest} [refreshRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityRefreshPOST(refreshRequest?: RefreshRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityRefreshPOST(refreshRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.identityRefreshPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterRequest} [registerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityRegisterPOST(registerRequest?: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityRegisterPOST(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.identityRegisterPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ResendConfirmationEmailRequest} [resendConfirmationEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityResendConfirmationEmailPOST(resendConfirmationEmailRequest?: ResendConfirmationEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityResendConfirmationEmailPOST(resendConfirmationEmailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.identityResendConfirmationEmailPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ResetPasswordRequest} [resetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityResetPasswordPOST(resetPasswordRequest?: ResetPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityResetPasswordPOST(resetPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.identityResetPasswordPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IdentityApi - factory interface
 * @export
 */
export const IdentityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentityApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [code] 
         * @param {string} [changedEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityConfirmEmailGET(userId?: string, code?: string, changedEmail?: string, options?: any): AxiosPromise<void> {
            return localVarFp.identityConfirmEmailGET(userId, code, changedEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityForgotPasswordPOST(forgotPasswordRequest?: ForgotPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.identityForgotPasswordPOST(forgotPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [useCookies] 
         * @param {boolean} [useSessionCookies] 
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityLoginPOST(useCookies?: boolean, useSessionCookies?: boolean, loginRequest?: LoginRequest, options?: any): AxiosPromise<AccessTokenResponse> {
            return localVarFp.identityLoginPOST(useCookies, useSessionCookies, loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TwoFactorRequest} [twoFactorRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityManage2faPOST(twoFactorRequest?: TwoFactorRequest, options?: any): AxiosPromise<TwoFactorResponse> {
            return localVarFp.identityManage2faPOST(twoFactorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityManageInfoGET(options?: any): AxiosPromise<InfoResponse> {
            return localVarFp.identityManageInfoGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InfoRequest} [infoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityManageInfoPOST(infoRequest?: InfoRequest, options?: any): AxiosPromise<InfoResponse> {
            return localVarFp.identityManageInfoPOST(infoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RefreshRequest} [refreshRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityRefreshPOST(refreshRequest?: RefreshRequest, options?: any): AxiosPromise<AccessTokenResponse> {
            return localVarFp.identityRefreshPOST(refreshRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterRequest} [registerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityRegisterPOST(registerRequest?: RegisterRequest, options?: any): AxiosPromise<void> {
            return localVarFp.identityRegisterPOST(registerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ResendConfirmationEmailRequest} [resendConfirmationEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityResendConfirmationEmailPOST(resendConfirmationEmailRequest?: ResendConfirmationEmailRequest, options?: any): AxiosPromise<void> {
            return localVarFp.identityResendConfirmationEmailPOST(resendConfirmationEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ResetPasswordRequest} [resetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityResetPasswordPOST(resetPasswordRequest?: ResetPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.identityResetPasswordPOST(resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdentityApi - object-oriented interface
 * @export
 * @class IdentityApi
 * @extends {BaseAPI}
 */
export class IdentityApi extends BaseAPI {
    /**
     * 
     * @param {string} [userId] 
     * @param {string} [code] 
     * @param {string} [changedEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public identityConfirmEmailGET(userId?: string, code?: string, changedEmail?: string, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).identityConfirmEmailGET(userId, code, changedEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public identityForgotPasswordPOST(forgotPasswordRequest?: ForgotPasswordRequest, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).identityForgotPasswordPOST(forgotPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [useCookies] 
     * @param {boolean} [useSessionCookies] 
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public identityLoginPOST(useCookies?: boolean, useSessionCookies?: boolean, loginRequest?: LoginRequest, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).identityLoginPOST(useCookies, useSessionCookies, loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TwoFactorRequest} [twoFactorRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public identityManage2faPOST(twoFactorRequest?: TwoFactorRequest, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).identityManage2faPOST(twoFactorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public identityManageInfoGET(options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).identityManageInfoGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InfoRequest} [infoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public identityManageInfoPOST(infoRequest?: InfoRequest, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).identityManageInfoPOST(infoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RefreshRequest} [refreshRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public identityRefreshPOST(refreshRequest?: RefreshRequest, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).identityRefreshPOST(refreshRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterRequest} [registerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public identityRegisterPOST(registerRequest?: RegisterRequest, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).identityRegisterPOST(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ResendConfirmationEmailRequest} [resendConfirmationEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public identityResendConfirmationEmailPOST(resendConfirmationEmailRequest?: ResendConfirmationEmailRequest, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).identityResendConfirmationEmailPOST(resendConfirmationEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ResetPasswordRequest} [resetPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public identityResetPasswordPOST(resetPasswordRequest?: ResetPasswordRequest, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).identityResetPasswordPOST(resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SudokuModuleSudokuEndpointsApi - axios parameter creator
 * @export
 */
export const SudokuModuleSudokuEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sudokuBoard: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sudoku`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SudokuModuleSudokuEndpointsApi - functional programming interface
 * @export
 */
export const SudokuModuleSudokuEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SudokuModuleSudokuEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sudokuBoard(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardDataDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sudokuBoard(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SudokuModuleSudokuEndpointsApi.sudokuBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SudokuModuleSudokuEndpointsApi - factory interface
 * @export
 */
export const SudokuModuleSudokuEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SudokuModuleSudokuEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sudokuBoard(options?: any): AxiosPromise<BoardDataDto> {
            return localVarFp.sudokuBoard(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SudokuModuleSudokuEndpointsApi - object-oriented interface
 * @export
 * @class SudokuModuleSudokuEndpointsApi
 * @extends {BaseAPI}
 */
export class SudokuModuleSudokuEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SudokuModuleSudokuEndpointsApi
     */
    public sudokuBoard(options?: RawAxiosRequestConfig) {
        return SudokuModuleSudokuEndpointsApiFp(this.configuration).sudokuBoard(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TimeTrackingModuleProjectEndpointsApi - axios parameter creator
 * @export
 */
export const TimeTrackingModuleProjectEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateProjectInput} createProjectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreate: async (createProjectInput: CreateProjectInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectInput' is not null or undefined
            assertParamExists('projectsCreate', 'createProjectInput', createProjectInput)
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsDelete', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsGetById', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchProjectCommandDto} patchProjectCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsPatch: async (id: string, patchProjectCommandDto: PatchProjectCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsPatch', 'id', id)
            // verify required parameter 'patchProjectCommandDto' is not null or undefined
            assertParamExists('projectsPatch', 'patchProjectCommandDto', patchProjectCommandDto)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchProjectCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProjectCommandDto} updateProjectCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdate: async (id: string, updateProjectCommandDto: UpdateProjectCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsUpdate', 'id', id)
            // verify required parameter 'updateProjectCommandDto' is not null or undefined
            assertParamExists('projectsUpdate', 'updateProjectCommandDto', updateProjectCommandDto)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeTrackingModuleProjectEndpointsApi - functional programming interface
 * @export
 */
export const TimeTrackingModuleProjectEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeTrackingModuleProjectEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateProjectInput} createProjectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsCreate(createProjectInput: CreateProjectInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsCreate(createProjectInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleProjectEndpointsApi.projectsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleProjectEndpointsApi.projectsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleProjectEndpointsApi.projectsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsGetById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleProjectEndpointsApi.projectsGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchProjectCommandDto} patchProjectCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsPatch(id: string, patchProjectCommandDto: PatchProjectCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsPatch(id, patchProjectCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleProjectEndpointsApi.projectsPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProjectCommandDto} updateProjectCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsUpdate(id: string, updateProjectCommandDto: UpdateProjectCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsUpdate(id, updateProjectCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleProjectEndpointsApi.projectsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TimeTrackingModuleProjectEndpointsApi - factory interface
 * @export
 */
export const TimeTrackingModuleProjectEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeTrackingModuleProjectEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateProjectInput} createProjectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreate(createProjectInput: CreateProjectInput, options?: any): AxiosPromise<void> {
            return localVarFp.projectsCreate(createProjectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetAll(options?: any): AxiosPromise<Array<ProjectDto>> {
            return localVarFp.projectsGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetById(id: string, options?: any): AxiosPromise<ProjectDto> {
            return localVarFp.projectsGetById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchProjectCommandDto} patchProjectCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsPatch(id: string, patchProjectCommandDto: PatchProjectCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.projectsPatch(id, patchProjectCommandDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProjectCommandDto} updateProjectCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdate(id: string, updateProjectCommandDto: UpdateProjectCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.projectsUpdate(id, updateProjectCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeTrackingModuleProjectEndpointsApi - object-oriented interface
 * @export
 * @class TimeTrackingModuleProjectEndpointsApi
 * @extends {BaseAPI}
 */
export class TimeTrackingModuleProjectEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {CreateProjectInput} createProjectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleProjectEndpointsApi
     */
    public projectsCreate(createProjectInput: CreateProjectInput, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleProjectEndpointsApiFp(this.configuration).projectsCreate(createProjectInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleProjectEndpointsApi
     */
    public projectsDelete(id: string, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleProjectEndpointsApiFp(this.configuration).projectsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleProjectEndpointsApi
     */
    public projectsGetAll(options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleProjectEndpointsApiFp(this.configuration).projectsGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleProjectEndpointsApi
     */
    public projectsGetById(id: string, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleProjectEndpointsApiFp(this.configuration).projectsGetById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PatchProjectCommandDto} patchProjectCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleProjectEndpointsApi
     */
    public projectsPatch(id: string, patchProjectCommandDto: PatchProjectCommandDto, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleProjectEndpointsApiFp(this.configuration).projectsPatch(id, patchProjectCommandDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateProjectCommandDto} updateProjectCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleProjectEndpointsApi
     */
    public projectsUpdate(id: string, updateProjectCommandDto: UpdateProjectCommandDto, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleProjectEndpointsApiFp(this.configuration).projectsUpdate(id, updateProjectCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TimeTrackingModuleWorkTaskEndpointsApi - axios parameter creator
 * @export
 */
export const TimeTrackingModuleWorkTaskEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateWorkTaskInput} createWorkTaskInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksCreate: async (createWorkTaskInput: CreateWorkTaskInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkTaskInput' is not null or undefined
            assertParamExists('workTasksCreate', 'createWorkTaskInput', createWorkTaskInput)
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkTaskInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workTasksDelete', 'id', id)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workTasksGetById', 'id', id)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchWorkTaskCommandDto} patchWorkTaskCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksPatch: async (id: string, patchWorkTaskCommandDto: PatchWorkTaskCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workTasksPatch', 'id', id)
            // verify required parameter 'patchWorkTaskCommandDto' is not null or undefined
            assertParamExists('workTasksPatch', 'patchWorkTaskCommandDto', patchWorkTaskCommandDto)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchWorkTaskCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StartWorkTaskInput} startWorkTaskInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksStart: async (startWorkTaskInput: StartWorkTaskInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startWorkTaskInput' is not null or undefined
            assertParamExists('workTasksStart', 'startWorkTaskInput', startWorkTaskInput)
            const localVarPath = `/tasks/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startWorkTaskInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWorkTaskCommandDto} updateWorkTaskCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksUpdate: async (id: string, updateWorkTaskCommandDto: UpdateWorkTaskCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workTasksUpdate', 'id', id)
            // verify required parameter 'updateWorkTaskCommandDto' is not null or undefined
            assertParamExists('workTasksUpdate', 'updateWorkTaskCommandDto', updateWorkTaskCommandDto)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWorkTaskCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeTrackingModuleWorkTaskEndpointsApi - functional programming interface
 * @export
 */
export const TimeTrackingModuleWorkTaskEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeTrackingModuleWorkTaskEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateWorkTaskInput} createWorkTaskInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTasksCreate(createWorkTaskInput: CreateWorkTaskInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTasksCreate(createWorkTaskInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleWorkTaskEndpointsApi.workTasksCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTasksDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTasksDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleWorkTaskEndpointsApi.workTasksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTasksGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkTaskDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTasksGetById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleWorkTaskEndpointsApi.workTasksGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTasksList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkTaskListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTasksList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleWorkTaskEndpointsApi.workTasksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchWorkTaskCommandDto} patchWorkTaskCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTasksPatch(id: string, patchWorkTaskCommandDto: PatchWorkTaskCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTasksPatch(id, patchWorkTaskCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleWorkTaskEndpointsApi.workTasksPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {StartWorkTaskInput} startWorkTaskInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTasksStart(startWorkTaskInput: StartWorkTaskInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTasksStart(startWorkTaskInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleWorkTaskEndpointsApi.workTasksStart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWorkTaskCommandDto} updateWorkTaskCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTasksUpdate(id: string, updateWorkTaskCommandDto: UpdateWorkTaskCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTasksUpdate(id, updateWorkTaskCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleWorkTaskEndpointsApi.workTasksUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TimeTrackingModuleWorkTaskEndpointsApi - factory interface
 * @export
 */
export const TimeTrackingModuleWorkTaskEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeTrackingModuleWorkTaskEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateWorkTaskInput} createWorkTaskInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksCreate(createWorkTaskInput: CreateWorkTaskInput, options?: any): AxiosPromise<void> {
            return localVarFp.workTasksCreate(createWorkTaskInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.workTasksDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksGetById(id: string, options?: any): AxiosPromise<WorkTaskDto> {
            return localVarFp.workTasksGetById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksList(options?: any): AxiosPromise<WorkTaskListResponse> {
            return localVarFp.workTasksList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchWorkTaskCommandDto} patchWorkTaskCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksPatch(id: string, patchWorkTaskCommandDto: PatchWorkTaskCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.workTasksPatch(id, patchWorkTaskCommandDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StartWorkTaskInput} startWorkTaskInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksStart(startWorkTaskInput: StartWorkTaskInput, options?: any): AxiosPromise<void> {
            return localVarFp.workTasksStart(startWorkTaskInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWorkTaskCommandDto} updateWorkTaskCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksUpdate(id: string, updateWorkTaskCommandDto: UpdateWorkTaskCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.workTasksUpdate(id, updateWorkTaskCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeTrackingModuleWorkTaskEndpointsApi - object-oriented interface
 * @export
 * @class TimeTrackingModuleWorkTaskEndpointsApi
 * @extends {BaseAPI}
 */
export class TimeTrackingModuleWorkTaskEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {CreateWorkTaskInput} createWorkTaskInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleWorkTaskEndpointsApi
     */
    public workTasksCreate(createWorkTaskInput: CreateWorkTaskInput, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleWorkTaskEndpointsApiFp(this.configuration).workTasksCreate(createWorkTaskInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleWorkTaskEndpointsApi
     */
    public workTasksDelete(id: string, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleWorkTaskEndpointsApiFp(this.configuration).workTasksDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleWorkTaskEndpointsApi
     */
    public workTasksGetById(id: string, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleWorkTaskEndpointsApiFp(this.configuration).workTasksGetById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleWorkTaskEndpointsApi
     */
    public workTasksList(options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleWorkTaskEndpointsApiFp(this.configuration).workTasksList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PatchWorkTaskCommandDto} patchWorkTaskCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleWorkTaskEndpointsApi
     */
    public workTasksPatch(id: string, patchWorkTaskCommandDto: PatchWorkTaskCommandDto, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleWorkTaskEndpointsApiFp(this.configuration).workTasksPatch(id, patchWorkTaskCommandDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StartWorkTaskInput} startWorkTaskInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleWorkTaskEndpointsApi
     */
    public workTasksStart(startWorkTaskInput: StartWorkTaskInput, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleWorkTaskEndpointsApiFp(this.configuration).workTasksStart(startWorkTaskInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateWorkTaskCommandDto} updateWorkTaskCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleWorkTaskEndpointsApi
     */
    public workTasksUpdate(id: string, updateWorkTaskCommandDto: UpdateWorkTaskCommandDto, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleWorkTaskEndpointsApiFp(this.configuration).workTasksUpdate(id, updateWorkTaskCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}



