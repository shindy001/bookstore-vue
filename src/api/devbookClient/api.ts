/* tslint:disable */
/* eslint-disable */
/**
 * DevBook.API, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccessTokenResponse
 */
export interface AccessTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof AccessTokenResponse
     */
    'tokenType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AccessTokenResponse
     */
    'accessToken': string | null;
    /**
     * 
     * @type {number}
     * @memberof AccessTokenResponse
     */
    'expiresIn': number;
    /**
     * 
     * @type {string}
     * @memberof AccessTokenResponse
     */
    'refreshToken': string | null;
}
/**
 * 
 * @export
 * @interface BoardDataDto
 */
export interface BoardDataDto {
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof BoardDataDto
     */
    'gridNumbers': Array<Array<number>>;
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof BoardDataDto
     */
    'solutionNumbers': Array<Array<number>>;
}
/**
 * 
 * @export
 * @interface BookDto
 */
export interface BookDto {
    /**
     * 
     * @type {string}
     * @memberof BookDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BookDto
     */
    'name': string;
    /**
     * 
     * @type {ProductType}
     * @memberof BookDto
     */
    'productType': ProductType;
    /**
     * 
     * @type {number}
     * @memberof BookDto
     */
    'retailPrice': number;
    /**
     * 
     * @type {number}
     * @memberof BookDto
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof BookDto
     */
    'discountAmmount': number;
    /**
     * 
     * @type {string}
     * @memberof BookDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookDto
     */
    'coverImageUrl'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BookDto
     */
    'productCategoryIds'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof BookDto
     */
    'author'?: string | null;
}


/**
 * 
 * @export
 * @interface CreateBookCommand
 */
export interface CreateBookCommand {
    /**
     * 
     * @type {string}
     * @memberof CreateBookCommand
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CreateBookCommand
     */
    'retailPrice': number;
    /**
     * 
     * @type {number}
     * @memberof CreateBookCommand
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof CreateBookCommand
     */
    'discountAmmount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateBookCommand
     */
    'author'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateBookCommand
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateBookCommand
     */
    'coverImageUrl'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBookCommand
     */
    'productCategoryIds'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreateProductCategoryCommand
 */
export interface CreateProductCategoryCommand {
    /**
     * 
     * @type {string}
     * @memberof CreateProductCategoryCommand
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateProductCategoryCommand
     */
    'isTopLevelCategory'?: boolean | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateProductCategoryCommand
     */
    'subcategories'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreateProjectInput
 */
export interface CreateProjectInput {
    /**
     * 
     * @type {string}
     * @memberof CreateProjectInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProjectInput
     */
    'details'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreateProjectInput
     */
    'hourlyRate'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreateProjectInput
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateProjectInput
     */
    'hexColor'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateWorkTaskInput
 */
export interface CreateWorkTaskInput {
    /**
     * 
     * @type {string}
     * @memberof CreateWorkTaskInput
     */
    'projectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkTaskInput
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkTaskInput
     */
    'details'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkTaskInput
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkTaskInput
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkTaskInput
     */
    'end': string;
}
/**
 * 
 * @export
 * @interface HttpValidationProblemDetails
 */
export interface HttpValidationProblemDetails {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof HttpValidationProblemDetails
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof HttpValidationProblemDetails
     */
    'title'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof HttpValidationProblemDetails
     */
    'status'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof HttpValidationProblemDetails
     */
    'detail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof HttpValidationProblemDetails
     */
    'instance'?: string | null;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof HttpValidationProblemDetails
     */
    'errors'?: { [key: string]: Array<string>; } | null;
}
/**
 * 
 * @export
 * @interface InfoResponse
 */
export interface InfoResponse {
    /**
     * 
     * @type {string}
     * @memberof InfoResponse
     */
    'email': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InfoResponse
     */
    'roles': Array<string>;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface PatchBookCommandDto
 */
export interface PatchBookCommandDto {
    /**
     * 
     * @type {string}
     * @memberof PatchBookCommandDto
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchBookCommandDto
     */
    'retailPrice'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchBookCommandDto
     */
    'price'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchBookCommandDto
     */
    'discountAmmount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchBookCommandDto
     */
    'author'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchBookCommandDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchBookCommandDto
     */
    'coverImageUrl'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchBookCommandDto
     */
    'productCategoryIds'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface PatchProjectCommandDto
 */
export interface PatchProjectCommandDto {
    /**
     * 
     * @type {string}
     * @memberof PatchProjectCommandDto
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchProjectCommandDto
     */
    'details'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchProjectCommandDto
     */
    'hourlyRate'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchProjectCommandDto
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchProjectCommandDto
     */
    'hexColor'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchWorkTaskCommandDto
 */
export interface PatchWorkTaskCommandDto {
    /**
     * 
     * @type {string}
     * @memberof PatchWorkTaskCommandDto
     */
    'projectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchWorkTaskCommandDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchWorkTaskCommandDto
     */
    'details'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchWorkTaskCommandDto
     */
    'date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchWorkTaskCommandDto
     */
    'start'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchWorkTaskCommandDto
     */
    'end'?: string | null;
}
/**
 * 
 * @export
 * @interface ProductCategoryDto
 */
export interface ProductCategoryDto {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryDto
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductCategoryDto
     */
    'isTopLevelCategory'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductCategoryDto
     */
    'subcategories'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ProductDto
 */
export interface ProductDto {
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'name': string;
    /**
     * 
     * @type {ProductType}
     * @memberof ProductDto
     */
    'productType': ProductType;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    'retailPrice': number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof ProductDto
     */
    'discountAmmount': number;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'coverImageUrl'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductDto
     */
    'productCategoryIds'?: Array<string> | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ProductType = {
    Book: 'Book'
} as const;

export type ProductType = typeof ProductType[keyof typeof ProductType];


/**
 * @type ProductsGetAll200ResponseInner
 * @export
 */
export type ProductsGetAll200ResponseInner = BookDto;

/**
 * 
 * @export
 * @interface ProjectDto
 */
export interface ProjectDto {
    /**
     * 
     * @type {string}
     * @memberof ProjectDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDto
     */
    'details'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProjectDto
     */
    'hourlyRate'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectDto
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectDto
     */
    'hexColor'?: string | null;
}
/**
 * 
 * @export
 * @interface RefreshRequest
 */
export interface RefreshRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshRequest
     */
    'refreshToken': string | null;
}
/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'email': string | null;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'password': string | null;
}
/**
 * 
 * @export
 * @interface StartWorkTaskInput
 */
export interface StartWorkTaskInput {
    /**
     * 
     * @type {string}
     * @memberof StartWorkTaskInput
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StartWorkTaskInput
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof StartWorkTaskInput
     */
    'start': string;
}
/**
 * 
 * @export
 * @interface UpdateBookCommandDto
 */
export interface UpdateBookCommandDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateBookCommandDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof UpdateBookCommandDto
     */
    'retailPrice': number;
    /**
     * 
     * @type {number}
     * @memberof UpdateBookCommandDto
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof UpdateBookCommandDto
     */
    'discountAmmount': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateBookCommandDto
     */
    'author'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateBookCommandDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateBookCommandDto
     */
    'coverImageUrl'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateBookCommandDto
     */
    'productCategoryIds'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface UpdateProductCategoryCommandDto
 */
export interface UpdateProductCategoryCommandDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateProductCategoryCommandDto
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateProductCategoryCommandDto
     */
    'isTopLevelCategory': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateProductCategoryCommandDto
     */
    'subcategories': Array<string> | null;
}
/**
 * 
 * @export
 * @interface UpdateProjectCommandDto
 */
export interface UpdateProjectCommandDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectCommandDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectCommandDto
     */
    'details'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateProjectCommandDto
     */
    'hourlyRate'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectCommandDto
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectCommandDto
     */
    'hexColor'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateWorkTaskCommandDto
 */
export interface UpdateWorkTaskCommandDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkTaskCommandDto
     */
    'projectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkTaskCommandDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkTaskCommandDto
     */
    'details'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkTaskCommandDto
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkTaskCommandDto
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWorkTaskCommandDto
     */
    'end': string;
}
/**
 * 
 * @export
 * @interface WorkTaskDto
 */
export interface WorkTaskDto {
    /**
     * 
     * @type {string}
     * @memberof WorkTaskDto
     */
    'id': string;
    /**
     * 
     * @type {ProjectDto}
     * @memberof WorkTaskDto
     */
    'project'?: ProjectDto | null;
    /**
     * 
     * @type {string}
     * @memberof WorkTaskDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkTaskDto
     */
    'details'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkTaskDto
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof WorkTaskDto
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof WorkTaskDto
     */
    'end'?: string | null;
}
/**
 * 
 * @export
 * @interface WorkTaskListResponse
 */
export interface WorkTaskListResponse {
    /**
     * 
     * @type {WorkTaskDto}
     * @memberof WorkTaskListResponse
     */
    'activeWorkTask'?: WorkTaskDto | null;
    /**
     * 
     * @type {{ [key: string]: Array<WorkTaskDto>; }}
     * @memberof WorkTaskListResponse
     */
    'workTasksInDay'?: { [key: string]: Array<WorkTaskDto>; } | null;
}

/**
 * AccountModuleIdentityEndpointsApi - axios parameter creator
 * @export
 */
export const AccountModuleIdentityEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityLogin: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('identityLogin', 'loginRequest', loginRequest)
            const localVarPath = `/identity/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RefreshRequest} refreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityRefresh: async (refreshRequest: RefreshRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshRequest' is not null or undefined
            assertParamExists('identityRefresh', 'refreshRequest', refreshRequest)
            const localVarPath = `/identity/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityRegister: async (registerRequest: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('identityRegister', 'registerRequest', registerRequest)
            const localVarPath = `/identity/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountModuleIdentityEndpointsApi - functional programming interface
 * @export
 */
export const AccountModuleIdentityEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountModuleIdentityEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountModuleIdentityEndpointsApi.identityInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityLogin(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityLogin(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountModuleIdentityEndpointsApi.identityLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RefreshRequest} refreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityRefresh(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityRefresh(refreshRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountModuleIdentityEndpointsApi.identityRefresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityRegister(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityRegister(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountModuleIdentityEndpointsApi.identityRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountModuleIdentityEndpointsApi - factory interface
 * @export
 */
export const AccountModuleIdentityEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountModuleIdentityEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityInfo(options?: any): AxiosPromise<InfoResponse> {
            return localVarFp.identityInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityLogin(loginRequest: LoginRequest, options?: any): AxiosPromise<AccessTokenResponse> {
            return localVarFp.identityLogin(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RefreshRequest} refreshRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityRefresh(refreshRequest: RefreshRequest, options?: any): AxiosPromise<AccessTokenResponse> {
            return localVarFp.identityRefresh(refreshRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityRegister(registerRequest: RegisterRequest, options?: any): AxiosPromise<void> {
            return localVarFp.identityRegister(registerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountModuleIdentityEndpointsApi - object-oriented interface
 * @export
 * @class AccountModuleIdentityEndpointsApi
 * @extends {BaseAPI}
 */
export class AccountModuleIdentityEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountModuleIdentityEndpointsApi
     */
    public identityInfo(options?: RawAxiosRequestConfig) {
        return AccountModuleIdentityEndpointsApiFp(this.configuration).identityInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountModuleIdentityEndpointsApi
     */
    public identityLogin(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AccountModuleIdentityEndpointsApiFp(this.configuration).identityLogin(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RefreshRequest} refreshRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountModuleIdentityEndpointsApi
     */
    public identityRefresh(refreshRequest: RefreshRequest, options?: RawAxiosRequestConfig) {
        return AccountModuleIdentityEndpointsApiFp(this.configuration).identityRefresh(refreshRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountModuleIdentityEndpointsApi
     */
    public identityRegister(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig) {
        return AccountModuleIdentityEndpointsApiFp(this.configuration).identityRegister(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BookStoreModuleBookEndpointsApi - axios parameter creator
 * @export
 */
export const BookStoreModuleBookEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateBookCommand} createBookCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        booksCreate: async (createBookCommand: CreateBookCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBookCommand' is not null or undefined
            assertParamExists('booksCreate', 'createBookCommand', createBookCommand)
            const localVarPath = `/bookstore/books`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBookCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchBookCommandDto} patchBookCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        booksPatch: async (id: string, patchBookCommandDto: PatchBookCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('booksPatch', 'id', id)
            // verify required parameter 'patchBookCommandDto' is not null or undefined
            assertParamExists('booksPatch', 'patchBookCommandDto', patchBookCommandDto)
            const localVarPath = `/bookstore/books/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchBookCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateBookCommandDto} updateBookCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        booksUpdate: async (id: string, updateBookCommandDto: UpdateBookCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('booksUpdate', 'id', id)
            // verify required parameter 'updateBookCommandDto' is not null or undefined
            assertParamExists('booksUpdate', 'updateBookCommandDto', updateBookCommandDto)
            const localVarPath = `/bookstore/books/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBookCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookStoreModuleBookEndpointsApi - functional programming interface
 * @export
 */
export const BookStoreModuleBookEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookStoreModuleBookEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateBookCommand} createBookCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async booksCreate(createBookCommand: CreateBookCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.booksCreate(createBookCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleBookEndpointsApi.booksCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchBookCommandDto} patchBookCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async booksPatch(id: string, patchBookCommandDto: PatchBookCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.booksPatch(id, patchBookCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleBookEndpointsApi.booksPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateBookCommandDto} updateBookCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async booksUpdate(id: string, updateBookCommandDto: UpdateBookCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.booksUpdate(id, updateBookCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleBookEndpointsApi.booksUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BookStoreModuleBookEndpointsApi - factory interface
 * @export
 */
export const BookStoreModuleBookEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookStoreModuleBookEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateBookCommand} createBookCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        booksCreate(createBookCommand: CreateBookCommand, options?: any): AxiosPromise<void> {
            return localVarFp.booksCreate(createBookCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchBookCommandDto} patchBookCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        booksPatch(id: string, patchBookCommandDto: PatchBookCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.booksPatch(id, patchBookCommandDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateBookCommandDto} updateBookCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        booksUpdate(id: string, updateBookCommandDto: UpdateBookCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.booksUpdate(id, updateBookCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookStoreModuleBookEndpointsApi - object-oriented interface
 * @export
 * @class BookStoreModuleBookEndpointsApi
 * @extends {BaseAPI}
 */
export class BookStoreModuleBookEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {CreateBookCommand} createBookCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleBookEndpointsApi
     */
    public booksCreate(createBookCommand: CreateBookCommand, options?: RawAxiosRequestConfig) {
        return BookStoreModuleBookEndpointsApiFp(this.configuration).booksCreate(createBookCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PatchBookCommandDto} patchBookCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleBookEndpointsApi
     */
    public booksPatch(id: string, patchBookCommandDto: PatchBookCommandDto, options?: RawAxiosRequestConfig) {
        return BookStoreModuleBookEndpointsApiFp(this.configuration).booksPatch(id, patchBookCommandDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateBookCommandDto} updateBookCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleBookEndpointsApi
     */
    public booksUpdate(id: string, updateBookCommandDto: UpdateBookCommandDto, options?: RawAxiosRequestConfig) {
        return BookStoreModuleBookEndpointsApiFp(this.configuration).booksUpdate(id, updateBookCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BookStoreModuleProductCategoryEndpointsApi - axios parameter creator
 * @export
 */
export const BookStoreModuleProductCategoryEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateProductCategoryCommand} createProductCategoryCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesCreate: async (createProductCategoryCommand: CreateProductCategoryCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProductCategoryCommand' is not null or undefined
            assertParamExists('productCategoriesCreate', 'createProductCategoryCommand', createProductCategoryCommand)
            const localVarPath = `/bookstore/productCategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProductCategoryCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productCategoriesDelete', 'id', id)
            const localVarPath = `/bookstore/productCategories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesGetAll: async (pageSize?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bookstore/productCategories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (offset !== undefined) {
                localVarQueryParameter['Offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productCategoriesGetById', 'id', id)
            const localVarPath = `/bookstore/productCategories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProductCategoryCommandDto} updateProductCategoryCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesUpdate: async (id: string, updateProductCategoryCommandDto: UpdateProductCategoryCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productCategoriesUpdate', 'id', id)
            // verify required parameter 'updateProductCategoryCommandDto' is not null or undefined
            assertParamExists('productCategoriesUpdate', 'updateProductCategoryCommandDto', updateProductCategoryCommandDto)
            const localVarPath = `/bookstore/productCategories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductCategoryCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookStoreModuleProductCategoryEndpointsApi - functional programming interface
 * @export
 */
export const BookStoreModuleProductCategoryEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookStoreModuleProductCategoryEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateProductCategoryCommand} createProductCategoryCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoriesCreate(createProductCategoryCommand: CreateProductCategoryCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoriesCreate(createProductCategoryCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleProductCategoryEndpointsApi.productCategoriesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoriesDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoriesDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleProductCategoryEndpointsApi.productCategoriesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoriesGetAll(pageSize?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductCategoryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoriesGetAll(pageSize, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleProductCategoryEndpointsApi.productCategoriesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoriesGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoriesGetById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleProductCategoryEndpointsApi.productCategoriesGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProductCategoryCommandDto} updateProductCategoryCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoriesUpdate(id: string, updateProductCategoryCommandDto: UpdateProductCategoryCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoriesUpdate(id, updateProductCategoryCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleProductCategoryEndpointsApi.productCategoriesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BookStoreModuleProductCategoryEndpointsApi - factory interface
 * @export
 */
export const BookStoreModuleProductCategoryEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookStoreModuleProductCategoryEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateProductCategoryCommand} createProductCategoryCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesCreate(createProductCategoryCommand: CreateProductCategoryCommand, options?: any): AxiosPromise<void> {
            return localVarFp.productCategoriesCreate(createProductCategoryCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.productCategoriesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesGetAll(pageSize?: number, offset?: number, options?: any): AxiosPromise<Array<ProductCategoryDto>> {
            return localVarFp.productCategoriesGetAll(pageSize, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesGetById(id: string, options?: any): AxiosPromise<ProductCategoryDto> {
            return localVarFp.productCategoriesGetById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProductCategoryCommandDto} updateProductCategoryCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoriesUpdate(id: string, updateProductCategoryCommandDto: UpdateProductCategoryCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.productCategoriesUpdate(id, updateProductCategoryCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookStoreModuleProductCategoryEndpointsApi - object-oriented interface
 * @export
 * @class BookStoreModuleProductCategoryEndpointsApi
 * @extends {BaseAPI}
 */
export class BookStoreModuleProductCategoryEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {CreateProductCategoryCommand} createProductCategoryCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleProductCategoryEndpointsApi
     */
    public productCategoriesCreate(createProductCategoryCommand: CreateProductCategoryCommand, options?: RawAxiosRequestConfig) {
        return BookStoreModuleProductCategoryEndpointsApiFp(this.configuration).productCategoriesCreate(createProductCategoryCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleProductCategoryEndpointsApi
     */
    public productCategoriesDelete(id: string, options?: RawAxiosRequestConfig) {
        return BookStoreModuleProductCategoryEndpointsApiFp(this.configuration).productCategoriesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleProductCategoryEndpointsApi
     */
    public productCategoriesGetAll(pageSize?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return BookStoreModuleProductCategoryEndpointsApiFp(this.configuration).productCategoriesGetAll(pageSize, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleProductCategoryEndpointsApi
     */
    public productCategoriesGetById(id: string, options?: RawAxiosRequestConfig) {
        return BookStoreModuleProductCategoryEndpointsApiFp(this.configuration).productCategoriesGetById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateProductCategoryCommandDto} updateProductCategoryCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleProductCategoryEndpointsApi
     */
    public productCategoriesUpdate(id: string, updateProductCategoryCommandDto: UpdateProductCategoryCommandDto, options?: RawAxiosRequestConfig) {
        return BookStoreModuleProductCategoryEndpointsApiFp(this.configuration).productCategoriesUpdate(id, updateProductCategoryCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BookStoreModuleProductEndpointsApi - axios parameter creator
 * @export
 */
export const BookStoreModuleProductEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsDelete', 'id', id)
            const localVarPath = `/bookstore/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [offset] 
         * @param {ProductType} [productType] 
         * @param {string} [productCategoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGetAll: async (pageSize?: number, offset?: number, productType?: ProductType, productCategoryId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bookstore/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['PageSize'] = pageSize;
            }

            if (offset !== undefined) {
                localVarQueryParameter['Offset'] = offset;
            }

            if (productType !== undefined) {
                localVarQueryParameter['ProductType'] = productType;
            }

            if (productCategoryId !== undefined) {
                localVarQueryParameter['ProductCategoryId'] = productCategoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsGetById', 'id', id)
            const localVarPath = `/bookstore/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookStoreModuleProductEndpointsApi - functional programming interface
 * @export
 */
export const BookStoreModuleProductEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookStoreModuleProductEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleProductEndpointsApi.productsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [offset] 
         * @param {ProductType} [productType] 
         * @param {string} [productCategoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGetAll(pageSize?: number, offset?: number, productType?: ProductType, productCategoryId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductsGetAll200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGetAll(pageSize, offset, productType, productCategoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleProductEndpointsApi.productsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsGetAll200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGetById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookStoreModuleProductEndpointsApi.productsGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BookStoreModuleProductEndpointsApi - factory interface
 * @export
 */
export const BookStoreModuleProductEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookStoreModuleProductEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.productsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] 
         * @param {number} [offset] 
         * @param {ProductType} [productType] 
         * @param {string} [productCategoryId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGetAll(pageSize?: number, offset?: number, productType?: ProductType, productCategoryId?: string, options?: any): AxiosPromise<Array<ProductsGetAll200ResponseInner>> {
            return localVarFp.productsGetAll(pageSize, offset, productType, productCategoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGetById(id: string, options?: any): AxiosPromise<ProductsGetAll200ResponseInner> {
            return localVarFp.productsGetById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookStoreModuleProductEndpointsApi - object-oriented interface
 * @export
 * @class BookStoreModuleProductEndpointsApi
 * @extends {BaseAPI}
 */
export class BookStoreModuleProductEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleProductEndpointsApi
     */
    public productsDelete(id: string, options?: RawAxiosRequestConfig) {
        return BookStoreModuleProductEndpointsApiFp(this.configuration).productsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] 
     * @param {number} [offset] 
     * @param {ProductType} [productType] 
     * @param {string} [productCategoryId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleProductEndpointsApi
     */
    public productsGetAll(pageSize?: number, offset?: number, productType?: ProductType, productCategoryId?: string, options?: RawAxiosRequestConfig) {
        return BookStoreModuleProductEndpointsApiFp(this.configuration).productsGetAll(pageSize, offset, productType, productCategoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookStoreModuleProductEndpointsApi
     */
    public productsGetById(id: string, options?: RawAxiosRequestConfig) {
        return BookStoreModuleProductEndpointsApiFp(this.configuration).productsGetById(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SudokuModuleSudokuEndpointsApi - axios parameter creator
 * @export
 */
export const SudokuModuleSudokuEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sudokuBoard: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sudoku`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SudokuModuleSudokuEndpointsApi - functional programming interface
 * @export
 */
export const SudokuModuleSudokuEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SudokuModuleSudokuEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sudokuBoard(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardDataDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sudokuBoard(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SudokuModuleSudokuEndpointsApi.sudokuBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SudokuModuleSudokuEndpointsApi - factory interface
 * @export
 */
export const SudokuModuleSudokuEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SudokuModuleSudokuEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sudokuBoard(options?: any): AxiosPromise<BoardDataDto> {
            return localVarFp.sudokuBoard(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SudokuModuleSudokuEndpointsApi - object-oriented interface
 * @export
 * @class SudokuModuleSudokuEndpointsApi
 * @extends {BaseAPI}
 */
export class SudokuModuleSudokuEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SudokuModuleSudokuEndpointsApi
     */
    public sudokuBoard(options?: RawAxiosRequestConfig) {
        return SudokuModuleSudokuEndpointsApiFp(this.configuration).sudokuBoard(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TimeTrackingModuleProjectEndpointsApi - axios parameter creator
 * @export
 */
export const TimeTrackingModuleProjectEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateProjectInput} createProjectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreate: async (createProjectInput: CreateProjectInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectInput' is not null or undefined
            assertParamExists('projectsCreate', 'createProjectInput', createProjectInput)
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsDelete', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsGetById', 'id', id)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchProjectCommandDto} patchProjectCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsPatch: async (id: string, patchProjectCommandDto: PatchProjectCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsPatch', 'id', id)
            // verify required parameter 'patchProjectCommandDto' is not null or undefined
            assertParamExists('projectsPatch', 'patchProjectCommandDto', patchProjectCommandDto)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchProjectCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProjectCommandDto} updateProjectCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdate: async (id: string, updateProjectCommandDto: UpdateProjectCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsUpdate', 'id', id)
            // verify required parameter 'updateProjectCommandDto' is not null or undefined
            assertParamExists('projectsUpdate', 'updateProjectCommandDto', updateProjectCommandDto)
            const localVarPath = `/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeTrackingModuleProjectEndpointsApi - functional programming interface
 * @export
 */
export const TimeTrackingModuleProjectEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeTrackingModuleProjectEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateProjectInput} createProjectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsCreate(createProjectInput: CreateProjectInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsCreate(createProjectInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleProjectEndpointsApi.projectsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleProjectEndpointsApi.projectsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleProjectEndpointsApi.projectsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsGetById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleProjectEndpointsApi.projectsGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchProjectCommandDto} patchProjectCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsPatch(id: string, patchProjectCommandDto: PatchProjectCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsPatch(id, patchProjectCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleProjectEndpointsApi.projectsPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProjectCommandDto} updateProjectCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsUpdate(id: string, updateProjectCommandDto: UpdateProjectCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsUpdate(id, updateProjectCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleProjectEndpointsApi.projectsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TimeTrackingModuleProjectEndpointsApi - factory interface
 * @export
 */
export const TimeTrackingModuleProjectEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeTrackingModuleProjectEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateProjectInput} createProjectInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreate(createProjectInput: CreateProjectInput, options?: any): AxiosPromise<void> {
            return localVarFp.projectsCreate(createProjectInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetAll(options?: any): AxiosPromise<Array<ProjectDto>> {
            return localVarFp.projectsGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetById(id: string, options?: any): AxiosPromise<ProjectDto> {
            return localVarFp.projectsGetById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchProjectCommandDto} patchProjectCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsPatch(id: string, patchProjectCommandDto: PatchProjectCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.projectsPatch(id, patchProjectCommandDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateProjectCommandDto} updateProjectCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdate(id: string, updateProjectCommandDto: UpdateProjectCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.projectsUpdate(id, updateProjectCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeTrackingModuleProjectEndpointsApi - object-oriented interface
 * @export
 * @class TimeTrackingModuleProjectEndpointsApi
 * @extends {BaseAPI}
 */
export class TimeTrackingModuleProjectEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {CreateProjectInput} createProjectInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleProjectEndpointsApi
     */
    public projectsCreate(createProjectInput: CreateProjectInput, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleProjectEndpointsApiFp(this.configuration).projectsCreate(createProjectInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleProjectEndpointsApi
     */
    public projectsDelete(id: string, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleProjectEndpointsApiFp(this.configuration).projectsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleProjectEndpointsApi
     */
    public projectsGetAll(options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleProjectEndpointsApiFp(this.configuration).projectsGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleProjectEndpointsApi
     */
    public projectsGetById(id: string, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleProjectEndpointsApiFp(this.configuration).projectsGetById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PatchProjectCommandDto} patchProjectCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleProjectEndpointsApi
     */
    public projectsPatch(id: string, patchProjectCommandDto: PatchProjectCommandDto, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleProjectEndpointsApiFp(this.configuration).projectsPatch(id, patchProjectCommandDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateProjectCommandDto} updateProjectCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleProjectEndpointsApi
     */
    public projectsUpdate(id: string, updateProjectCommandDto: UpdateProjectCommandDto, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleProjectEndpointsApiFp(this.configuration).projectsUpdate(id, updateProjectCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TimeTrackingModuleWorkTaskEndpointsApi - axios parameter creator
 * @export
 */
export const TimeTrackingModuleWorkTaskEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateWorkTaskInput} createWorkTaskInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksCreate: async (createWorkTaskInput: CreateWorkTaskInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkTaskInput' is not null or undefined
            assertParamExists('workTasksCreate', 'createWorkTaskInput', createWorkTaskInput)
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkTaskInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workTasksDelete', 'id', id)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workTasksGetById', 'id', id)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchWorkTaskCommandDto} patchWorkTaskCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksPatch: async (id: string, patchWorkTaskCommandDto: PatchWorkTaskCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workTasksPatch', 'id', id)
            // verify required parameter 'patchWorkTaskCommandDto' is not null or undefined
            assertParamExists('workTasksPatch', 'patchWorkTaskCommandDto', patchWorkTaskCommandDto)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchWorkTaskCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StartWorkTaskInput} startWorkTaskInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksStart: async (startWorkTaskInput: StartWorkTaskInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startWorkTaskInput' is not null or undefined
            assertParamExists('workTasksStart', 'startWorkTaskInput', startWorkTaskInput)
            const localVarPath = `/tasks/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startWorkTaskInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWorkTaskCommandDto} updateWorkTaskCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksUpdate: async (id: string, updateWorkTaskCommandDto: UpdateWorkTaskCommandDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workTasksUpdate', 'id', id)
            // verify required parameter 'updateWorkTaskCommandDto' is not null or undefined
            assertParamExists('workTasksUpdate', 'updateWorkTaskCommandDto', updateWorkTaskCommandDto)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWorkTaskCommandDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeTrackingModuleWorkTaskEndpointsApi - functional programming interface
 * @export
 */
export const TimeTrackingModuleWorkTaskEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimeTrackingModuleWorkTaskEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateWorkTaskInput} createWorkTaskInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTasksCreate(createWorkTaskInput: CreateWorkTaskInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTasksCreate(createWorkTaskInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleWorkTaskEndpointsApi.workTasksCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTasksDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTasksDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleWorkTaskEndpointsApi.workTasksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTasksGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkTaskDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTasksGetById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleWorkTaskEndpointsApi.workTasksGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTasksList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkTaskListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTasksList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleWorkTaskEndpointsApi.workTasksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchWorkTaskCommandDto} patchWorkTaskCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTasksPatch(id: string, patchWorkTaskCommandDto: PatchWorkTaskCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTasksPatch(id, patchWorkTaskCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleWorkTaskEndpointsApi.workTasksPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {StartWorkTaskInput} startWorkTaskInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTasksStart(startWorkTaskInput: StartWorkTaskInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTasksStart(startWorkTaskInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleWorkTaskEndpointsApi.workTasksStart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWorkTaskCommandDto} updateWorkTaskCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workTasksUpdate(id: string, updateWorkTaskCommandDto: UpdateWorkTaskCommandDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workTasksUpdate(id, updateWorkTaskCommandDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimeTrackingModuleWorkTaskEndpointsApi.workTasksUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TimeTrackingModuleWorkTaskEndpointsApi - factory interface
 * @export
 */
export const TimeTrackingModuleWorkTaskEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimeTrackingModuleWorkTaskEndpointsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateWorkTaskInput} createWorkTaskInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksCreate(createWorkTaskInput: CreateWorkTaskInput, options?: any): AxiosPromise<void> {
            return localVarFp.workTasksCreate(createWorkTaskInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.workTasksDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksGetById(id: string, options?: any): AxiosPromise<WorkTaskDto> {
            return localVarFp.workTasksGetById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksList(options?: any): AxiosPromise<WorkTaskListResponse> {
            return localVarFp.workTasksList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PatchWorkTaskCommandDto} patchWorkTaskCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksPatch(id: string, patchWorkTaskCommandDto: PatchWorkTaskCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.workTasksPatch(id, patchWorkTaskCommandDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StartWorkTaskInput} startWorkTaskInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksStart(startWorkTaskInput: StartWorkTaskInput, options?: any): AxiosPromise<void> {
            return localVarFp.workTasksStart(startWorkTaskInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWorkTaskCommandDto} updateWorkTaskCommandDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workTasksUpdate(id: string, updateWorkTaskCommandDto: UpdateWorkTaskCommandDto, options?: any): AxiosPromise<void> {
            return localVarFp.workTasksUpdate(id, updateWorkTaskCommandDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeTrackingModuleWorkTaskEndpointsApi - object-oriented interface
 * @export
 * @class TimeTrackingModuleWorkTaskEndpointsApi
 * @extends {BaseAPI}
 */
export class TimeTrackingModuleWorkTaskEndpointsApi extends BaseAPI {
    /**
     * 
     * @param {CreateWorkTaskInput} createWorkTaskInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleWorkTaskEndpointsApi
     */
    public workTasksCreate(createWorkTaskInput: CreateWorkTaskInput, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleWorkTaskEndpointsApiFp(this.configuration).workTasksCreate(createWorkTaskInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleWorkTaskEndpointsApi
     */
    public workTasksDelete(id: string, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleWorkTaskEndpointsApiFp(this.configuration).workTasksDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleWorkTaskEndpointsApi
     */
    public workTasksGetById(id: string, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleWorkTaskEndpointsApiFp(this.configuration).workTasksGetById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleWorkTaskEndpointsApi
     */
    public workTasksList(options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleWorkTaskEndpointsApiFp(this.configuration).workTasksList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PatchWorkTaskCommandDto} patchWorkTaskCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleWorkTaskEndpointsApi
     */
    public workTasksPatch(id: string, patchWorkTaskCommandDto: PatchWorkTaskCommandDto, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleWorkTaskEndpointsApiFp(this.configuration).workTasksPatch(id, patchWorkTaskCommandDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StartWorkTaskInput} startWorkTaskInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleWorkTaskEndpointsApi
     */
    public workTasksStart(startWorkTaskInput: StartWorkTaskInput, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleWorkTaskEndpointsApiFp(this.configuration).workTasksStart(startWorkTaskInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateWorkTaskCommandDto} updateWorkTaskCommandDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeTrackingModuleWorkTaskEndpointsApi
     */
    public workTasksUpdate(id: string, updateWorkTaskCommandDto: UpdateWorkTaskCommandDto, options?: RawAxiosRequestConfig) {
        return TimeTrackingModuleWorkTaskEndpointsApiFp(this.configuration).workTasksUpdate(id, updateWorkTaskCommandDto, options).then((request) => request(this.axios, this.basePath));
    }
}



